// Code generated by protoc-gen-go.
// source: gmaj.proto
// DO NOT EDIT!

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	gmaj.proto

It has these top-level messages:
	RemoteNode
	TransferMsg
	Nil
	KeyVal
	ID
	Key
	Val
	Response
*/
package pb

import proto "github.com/golang/protobuf/proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type RemoteNode struct {
	Id   []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Addr string `protobuf:"bytes,2,opt,name=addr" json:"addr,omitempty"`
}

func (m *RemoteNode) Reset()         { *m = RemoteNode{} }
func (m *RemoteNode) String() string { return proto.CompactTextString(m) }
func (*RemoteNode) ProtoMessage()    {}

type TransferMsg struct {
	FromID []byte      `protobuf:"bytes,1,opt,name=fromID,proto3" json:"fromID,omitempty"`
	ToNode *RemoteNode `protobuf:"bytes,2,opt,name=toNode" json:"toNode,omitempty"`
}

func (m *TransferMsg) Reset()         { *m = TransferMsg{} }
func (m *TransferMsg) String() string { return proto.CompactTextString(m) }
func (*TransferMsg) ProtoMessage()    {}

func (m *TransferMsg) GetToNode() *RemoteNode {
	if m != nil {
		return m.ToNode
	}
	return nil
}

type Nil struct {
}

func (m *Nil) Reset()         { *m = Nil{} }
func (m *Nil) String() string { return proto.CompactTextString(m) }
func (*Nil) ProtoMessage()    {}

type KeyVal struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Val string `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
}

func (m *KeyVal) Reset()         { *m = KeyVal{} }
func (m *KeyVal) String() string { return proto.CompactTextString(m) }
func (*KeyVal) ProtoMessage()    {}

type ID struct {
	Id []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ID) Reset()         { *m = ID{} }
func (m *ID) String() string { return proto.CompactTextString(m) }
func (*ID) ProtoMessage()    {}

type Key struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *Key) Reset()         { *m = Key{} }
func (m *Key) String() string { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()    {}

type Val struct {
	Val string `protobuf:"bytes,1,opt,name=val" json:"val,omitempty"`
}

func (m *Val) Reset()         { *m = Val{} }
func (m *Val) String() string { return proto.CompactTextString(m) }
func (*Val) ProtoMessage()    {}

type Response struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}

func init() {
}

// Client API for Node service

type NodeClient interface {
	GetPredecessor(ctx context.Context, in *Nil, opts ...grpc.CallOption) (*RemoteNode, error)
	GetSuccessor(ctx context.Context, in *Nil, opts ...grpc.CallOption) (*RemoteNode, error)
	SetPredecessor(ctx context.Context, in *RemoteNode, opts ...grpc.CallOption) (*Response, error)
	SetSuccessor(ctx context.Context, in *RemoteNode, opts ...grpc.CallOption) (*Response, error)
	Notify(ctx context.Context, in *RemoteNode, opts ...grpc.CallOption) (*Response, error)
	ClosestPrecedingFinger(ctx context.Context, in *ID, opts ...grpc.CallOption) (*RemoteNode, error)
	FindSuccessor(ctx context.Context, in *ID, opts ...grpc.CallOption) (*RemoteNode, error)
	Get(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Val, error)
	Put(ctx context.Context, in *KeyVal, opts ...grpc.CallOption) (*Response, error)
	TransferKeys(ctx context.Context, in *TransferMsg, opts ...grpc.CallOption) (*Response, error)
}

type nodeClient struct {
	cc *grpc.ClientConn
}

func NewNodeClient(cc *grpc.ClientConn) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) GetPredecessor(ctx context.Context, in *Nil, opts ...grpc.CallOption) (*RemoteNode, error) {
	out := new(RemoteNode)
	err := grpc.Invoke(ctx, "/pb.Node/GetPredecessor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetSuccessor(ctx context.Context, in *Nil, opts ...grpc.CallOption) (*RemoteNode, error) {
	out := new(RemoteNode)
	err := grpc.Invoke(ctx, "/pb.Node/GetSuccessor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) SetPredecessor(ctx context.Context, in *RemoteNode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/pb.Node/SetPredecessor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) SetSuccessor(ctx context.Context, in *RemoteNode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/pb.Node/SetSuccessor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Notify(ctx context.Context, in *RemoteNode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/pb.Node/Notify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ClosestPrecedingFinger(ctx context.Context, in *ID, opts ...grpc.CallOption) (*RemoteNode, error) {
	out := new(RemoteNode)
	err := grpc.Invoke(ctx, "/pb.Node/ClosestPrecedingFinger", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) FindSuccessor(ctx context.Context, in *ID, opts ...grpc.CallOption) (*RemoteNode, error) {
	out := new(RemoteNode)
	err := grpc.Invoke(ctx, "/pb.Node/FindSuccessor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}

	return out, nil
}

func (c *nodeClient) Get(ctx context.Context, in *Key, opts ...grpc.CallOption) (*Val, error) {
	out := new(Val)
	err := grpc.Invoke(ctx, "/pb.Node/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Put(ctx context.Context, in *KeyVal, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/pb.Node/Put", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) TransferKeys(ctx context.Context, in *TransferMsg, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/pb.Node/TransferKeys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Node service

type NodeServer interface {
	GetPredecessor(context.Context, *Nil) (*RemoteNode, error)
	GetSuccessor(context.Context, *Nil) (*RemoteNode, error)
	SetPredecessor(context.Context, *RemoteNode) (*Response, error)
	SetSuccessor(context.Context, *RemoteNode) (*Response, error)
	Notify(context.Context, *RemoteNode) (*Response, error)
	ClosestPrecedingFinger(context.Context, *ID) (*RemoteNode, error)
	FindSuccessor(context.Context, *ID) (*RemoteNode, error)
	Get(context.Context, *Key) (*Val, error)
	Put(context.Context, *KeyVal) (*Response, error)
	TransferKeys(context.Context, *TransferMsg) (*Response, error)
}

func RegisterNodeServer(s *grpc.Server, srv NodeServer) {
	s.RegisterService(&_Node_serviceDesc, srv)
}

func _Node_GetPredecessor_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Nil)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NodeServer).GetPredecessor(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Node_GetSuccessor_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Nil)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NodeServer).GetSuccessor(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Node_SetPredecessor_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RemoteNode)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NodeServer).SetPredecessor(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Node_SetSuccessor_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RemoteNode)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NodeServer).SetSuccessor(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Node_Notify_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RemoteNode)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NodeServer).Notify(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Node_ClosestPrecedingFinger_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ID)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NodeServer).ClosestPrecedingFinger(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Node_FindSuccessor_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ID)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NodeServer).FindSuccessor(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Node_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Key)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NodeServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Node_Put_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(KeyVal)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NodeServer).Put(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Node_TransferKeys_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(TransferMsg)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NodeServer).TransferKeys(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Node_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPredecessor",
			Handler:    _Node_GetPredecessor_Handler,
		},
		{
			MethodName: "GetSuccessor",
			Handler:    _Node_GetSuccessor_Handler,
		},
		{
			MethodName: "SetPredecessor",
			Handler:    _Node_SetPredecessor_Handler,
		},
		{
			MethodName: "SetSuccessor",
			Handler:    _Node_SetSuccessor_Handler,
		},
		{
			MethodName: "Notify",
			Handler:    _Node_Notify_Handler,
		},
		{
			MethodName: "ClosestPrecedingFinger",
			Handler:    _Node_ClosestPrecedingFinger_Handler,
		},
		{
			MethodName: "FindSuccessor",
			Handler:    _Node_FindSuccessor_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Node_Get_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _Node_Put_Handler,
		},
		{
			MethodName: "TransferKeys",
			Handler:    _Node_TransferKeys_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
